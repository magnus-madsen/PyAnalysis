/// We can use Flix as an ordinary Datalog solver.

/// Declare two predicate symbols.
rel Alloc(var: str, heap: str, inMeth: str)
rel Move(to: str, from: str)
rel Load(to: str, base: str, fld: str)
rel Store(base: str, fld: str, from: str)
rel VCall(base: str, sig: str, invo: str, inMeth: str)

rel FormalArg(meth: str, n: str, arg: str)
rel ActualArg(invo: str, n: str, arg: str)
rel FormalReturn(meth: str, ret: str)
rel ActualReturn(invo: str, var: str)
rel HeapType(heap: str, type: str)
rel LookUp(type: str, sig: str, meth: str)
rel VarPointsTo(var: str, heap: str)
rel CallGraph(invo: str, meth: str)
rel FldPointsTo(baseH: str, fld: str, heap: str)
rel InterProcAssign(to: str, from: str)
rel Reachable(meth: str)


// Declare some constraints.
VarPointsTo(var, heap) :- Reachable(meth), Alloc(var, heap, meth).
VarPointsTo(to, heap) :- Move(to, from), VarPointsTo(from, heap).
FldPointsTo(baseH, fld, heap) :- Store(base, fld, from), VarPointsTo(from, heap),
    VarPointsTo(base, baseH).
VarPointsTo(to, heap) :- Load(to, base, fld), VarPointsTo(base, baseH), FldPointsTo(baseH,fld,heap).
Reachable(toMeth) :- VCall(base, sig, invo, inMeth), Reachable(inMeth), VarPointsTo(base, heap),
    HeapType(heap, heapT), LookUp(heapT, sig, toMeth).
CallGraph(invo, toMeth) :- VCall(base, sig, invo, inMeth), Reachable(inMeth), VarPointsTo(base, heap),
    HeapType(heap, heapT), LookUp(heapT, sig, toMeth).
InterProcAssign(to,from) :- CallGraph(invo, meth), FormalArg(meth, n, to), ActualArg(invo, n, from).
InterProcAssign(to,from) :- CallGraph(invo, meth), FormalReturn(meth, from), ActualReturn(invo, to).
VarPointsTo(to, heap) :- InterProcAssign(to, from), VarPointsTo(from, heap).
